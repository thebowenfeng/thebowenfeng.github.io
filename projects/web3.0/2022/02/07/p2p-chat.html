<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Decentralized peer-to-peer chatting using Python | Bowen’s Blog</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="Decentralized peer-to-peer chatting using Python">
<meta name="author" content="Bowen Feng">
<meta property="og:locale" content="en_US">
<meta name="description" content="Decentralization, and with it peer-to-peer (p2p), technologies has gradually become more popular with the advent of “Web 3.0”. This project aims to utilize several key concepts, such as UDP hole punching and signalling/rendezvous servers to implement a p2p chatting application using Python.">
<meta property="og:description" content="Decentralization, and with it peer-to-peer (p2p), technologies has gradually become more popular with the advent of “Web 3.0”. This project aims to utilize several key concepts, such as UDP hole punching and signalling/rendezvous servers to implement a p2p chatting application using Python.">
<link rel="canonical" href="https://blog.bowenfeng.xyz/projects/web3.0/2022/02/07/p2p-chat.html">
<meta property="og:url" content="https://blog.bowenfeng.xyz/projects/web3.0/2022/02/07/p2p-chat.html">
<meta property="og:site_name" content="Bowen’s Blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-02-07T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Decentralized peer-to-peer chatting using Python">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Bowen Feng"},"dateModified":"2022-02-07T00:00:00+00:00","datePublished":"2022-02-07T00:00:00+00:00","description":"Decentralization, and with it peer-to-peer (p2p), technologies has gradually become more popular with the advent of “Web 3.0”. This project aims to utilize several key concepts, such as UDP hole punching and signalling/rendezvous servers to implement a p2p chatting application using Python.","headline":"Decentralized peer-to-peer chatting using Python","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bowenfeng.xyz/projects/web3.0/2022/02/07/p2p-chat.html"},"url":"https://blog.bowenfeng.xyz/projects/web3.0/2022/02/07/p2p-chat.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="https://blog.bowenfeng.xyz/feed.xml" title="Bowen's Blog">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Bowen's Blog" src="" onerror="this.style.display='none'">
  Bowen's Blog
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/">HOME</a><a class="page-link" href="/tags.html">TAGS</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">Decentralized peer-to-peer chatting using Python</h1>
  <h2 class="post-subtitle"></h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2022-02-07T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Feb 07, 2022
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 8 mins</span>
  </p>
<div class="post-tags">
<a class="post-tag" href="/tags.html#Python">#Python</a><a class="post-tag" href="/tags.html#Network">#Network</a><a class="post-tag" href="/tags.html#Peer2Peer">#Peer2Peer</a><a class="post-tag" href="/tags.html#Decentralize">#Decentralize</a><a class="post-tag" href="/tags.html#Firebase">#Firebase</a>
</div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <p>Decentralization, and with it peer-to-peer (p2p), technologies has
gradually become more popular with the advent of “Web 3.0”. This
project aims to utilize several key concepts, such as UDP hole 
punching and signalling/rendezvous servers to implement a p2p
chatting application using Python.</p>

<h2 id="what-is-peer-to-peer-p2p">What is peer to peer (p2p)</h2>

<p>Peer to peer communication is a form of decentralized communication.
Traditionally, communication relied on the familiar client-server model, where 
each client sends messages to a central server and it is the role of the server
to broadcast messages to the appropriate client/clients. However, in a peer to
peer model, the idea is to bypass the need for a central server. Each client will
directly communicate with the desired recipient. How you may ask? This is where UDP
hole punching comes in.</p>

<p><a href="https://github.com/thebowenfeng/Python-P2P-Chat">Project link/source code</a></p>

<h2 id="what-is-nat-and-udp-hole-punching">What is NAT and UDP hole punching</h2>

<p>The main obstacle when it comes to trivial p2p communication is NAT, or network
address translation. To summarize, NAT is a method of binding several private
IP addresses (individual devices) to one public IP address (router), in order
to conserve IP addresses. Instead of each device having its separate public IP,
different devices connect to one router, who has one public IP, and incoming traffic
is handled by NAT, who forwards the right packets to the right computers.</p>

<p>Obviously, this poses a problem if an external client wishes to initiate a connection
with a device connected to the network. The remote device can only see the public IP,
under which multiple “internal” devices could be connected to (think a home router with
different devices). This problem could be mitigated by use of a signalling server
(or a rendezvous server), which essentially acts as an exchange medium between
two devices wishing to communicate with each other (will elaborate later). 
However, this brings us to the second problem, which is firewalls.</p>

<p>As you may expect, routers cannot, and should not be, accepting random data sent
from unknown external computers, which is the purpose of firewalls. Firewalls are 
designed to protect the network against possible attacks. As such, (most) NATs are designed
to stop unsolicited communication from external sources.</p>

<p>There are four main types of NATs: Full-cone, address-restricted cone, port-restricted cone,
and symmetric NAT (<a href="https://en.wikipedia.org/wiki/Network_address_translation">details</a>). UDP hole punching works with all the above configurations 
except for symmetric NAT (which is only typically used in large scale corporate network),
and as such will not be discussed.</p>

<p>Full-cone NAT is where an internal IP:port is mapped to an external IP:port, and 
any traffic sent to said external IP:port will be sent to the internal device. 
As you can imagine, this configuration is not very secure, and as such most modern
routers opts to use either address or port restricted cone NAT.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Full_Cone_NAT.svg/400px-Full_Cone_NAT.svg.png" alt="Full cone NAT"></p>

<p>Both address and port restricted cone NATs operate under the same premise, albeit
with slight differences. Both NATs will only allow packets sent to an IP:port if
an internal device has previously voluntarily sent a packet to the sender. In other words,
B can only talk to A if A have previously talked to B. The only difference between
an address and a port restricted cone NAT is that an address restricted cone NAT allows
inbound traffic from any port as long as an internal device has previously sent a packet
to the host. Whereas in a port restricted cone NAT, the inbound traffic have to be
from the correct host <strong>and</strong> correct port. If A sent a packet to B’s port 5000, then B can only
talk back to A if B sent its traffic through its own port 5000.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Restricted_Cone_NAT.svg/400px-Restricted_Cone_NAT.svg.png" alt="Address restricted cone NAT">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/Port_Restricted_Cone_NAT.svg/400px-Port_Restricted_Cone_NAT.svg.png" alt="Port restricted cone NAT"></p>

<p>This work great in a typical use case,
such as web browsing, as it allows inbound traffic <strong>if and only if</strong> the user 
voluntarily requested for it. However, this makes p2p communication challenging,
as the <strong>receiver</strong> has to <strong>initiate</strong> the communication process in order for it to work.
Or, to put it simply. if A want to talk to B, then B has to somehow magically know that
A wishes to talk (the magic is known as a signalling server), and initiate the conversation <strong>first</strong>.</p>

<p>So where does UDP hole punching comes in?</p>

<p>UDP hole punching refers to fact that the receiver has to “talk first”. It is a technique
where the recipient sends a single UDP packet to the sender in order to “punch a hole” in the firewall,
in order for the sender to be able to send information to the recipient. Why UDP you may ask? Isn’t UDP
horrible? In this case, because of the fact UDP does not expect a response (unlike TCP), 
it is perfect for the initial “hole punch” process, as the hole punching packet does not need
a response. <img src="https://i.pinimg.com/736x/53/3d/89/533d891d1f54a2481d5fb14d31ec7f29.jpg" alt="UDP vs TCP">
As mentioned above, this technique relies on some magical intuition from the receiver 
that someone is wants to talk to them, as the receiver has to initiate the punch. 
This leads to the purpose of a signalling server</p>

<h2 id="what-is-a-signalling-server">What is a signalling server</h2>

<p>Sadly, mind reading does not exist in this world (at least yet), which means 
decentralized p2p cannot be 100% decentralized, due to aforementioned problems. 
However, if one is to look past this slight inconvenience, signalling servers
is a great way to overcome the lack of magic.</p>

<p>To put simply, signalling server (or a rendezvous server) is a way for two clients
to express their intent to talk to each other, but not actually talk to each other. 
Although it is a form of centralization, the server merely captures <strong>intent</strong> 
to communicate, rather than the actual content of communication, which is of course
transmitted directly via p2p.</p>

<p>If A wishes to talk to B, then A could make an “offer” via the signalling server. 
All clients would be constantly listening/subscribed to the signalling server, so B should 
receive the offer from A. From the on, B could initiate a UDP hole punch using information
in the offer (such as sender/receiver IP, and sender port, which is the port to punch), whilst 
providing an answer to the offer to the signalling server. A would then receive 
answer via the signalling server (with information such as receiver listening port), 
and assuming the UDP hole punch is successful, could begin communicating with B.</p>

<h2 id="how-does-this-all-work-together">How does this all work together</h2>

<p>In this project, we will be using Python sockets and firebase-firestore as the signalling
server (due to its event listening capabilities). The workflow will look something like this:</p>

<ol>
  <li>Client A and Client B both initiate program and begin to listen for offers directed to them (from firebase)</li>
  <li>Client A wishes to send Client B a message (knowing their IP). Client A makes an offer with sender’s IP, receiver’s IP and sender’s port that will be punched (subsequently the port that A will communicate on)</li>
  <li>Since Client B is listening to firebase, they should receive the offer almost instantaneously, and using the information in the offer, initiate a UDP hole punch wherein Client B sends a single UDP packet to Client A on the port specified by A.</li>
  <li>After punching has been completed, Client B will respond to the offer by providing an answer with the port that it will be listening on</li>
  <li>A will receive the answer, and begins the communication with B.</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>Decentralized p2p communication is an exciting technology as it bypasses the need 
for a remote, central server in a world with ever-growing privacy concerns. 
This project aims to provide a basis for any application that requires communication,
by providing an alternative as opposed to the standard server-client model.</p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/projects/ai/computer%20vision/2022/01/07/ai-gamer.html" title="Using CNNs to autonomously play videogames">Using CNNs to autonomously play videogames...</a><a class="next" href="/projects/reverse%20engineering/2022/07/26/polymorphic-engine.html" title="Bypass code detection with polymorphic code engine">Bypass code detection with polymorphic code...</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/projects/web3.0/2022/02/07/p2p-chat.html" title="Bypass code detection with polymorphic code engine">Decentralized peer-to-peer chatting using Python</a></li>
<li><a class="post-link" href="/projects/reverse%20engineering/2022/07/26/polymorphic-engine.html" title="Bypass code detection with polymorphic code engine">Bypass code detection with polymorphic code engine</a></li>
<li><a class="post-link" href="/projects/reverse%20engineering/2023/09/09/shellcode-injection.html" title="Bypass code detection with polymorphic code engine">Loading encrypted shellcode at runtime - A CTF writeup</a></li>
<li><a class="post-link" href="/projects/nlp/2020/01/17/markov-chatbot.html" title="Bypass code detection with polymorphic code engine">Using Markov Chains to simulate human speech</a></li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Copyright <span class="copyleft">©</span> 2017-2024 Bowen Feng</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="http://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
